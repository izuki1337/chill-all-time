import discord
from discord.ext import commands
import aiohttp
import json
import os
import random
import re
from typing import Optional, List
from discord import app_commands

class bot_AI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.api_key = "f0aa1b7e119a5c19aca578e51ea3a1151d20ddae0808035aff653b65000b13f4"
        self.base_url = "https://api.together.xyz/v1/chat/completions"
        self.conversations = {}
        self.ai_channels = self.load_ai_channels()  # Load AI channels from file
        self.ai_enabled = True  
        self.emoji_patterns = {
            "happy": ["üòä", "üòÑ", "üòÅ", "ü•∞", "üòç", "üòé", "ü§ó"],
            "sad": ["üòî", "üò¢", "üò≠", "ü•∫", "üòû", "üòü"],
            "surprise": ["üò≤", "üòÆ", "üòØ", "üò≥", "ü§Ø", "üò±"],
            "thinking": ["ü§î", "üßê", "ü§®", "üôÑ", "ü§∑‚Äç‚ôÄÔ∏è", "ü§∑‚Äç‚ôÇÔ∏è"],
            "love": ["‚ù§Ô∏è", "üíï", "üíñ", "üíó", "üíì", "üíò"],
            "laugh": ["üòÇ", "ü§£", "üòÜ", "üòù", "üòú", "üòπ"],
            "agree": ["üëç", "üëå", "‚úÖ", "‚úì", "üôè", "üíØ"],
            "disagree": ["üëé", "‚ùå", "üö´", "‚õî", "üòï"]
        }
        
    def load_ai_channels(self) -> List[int]:
        """Load AI channels from file"""
        channels = []
        try:
            if os.path.exists("e:/bot self/data/ai_channels.txt"):
                with open("e:/bot self/data/ai_channels.txt", "r") as f:
                    for line in f:
                        try:
                            channel_id = int(line.strip())
                            channels.append(channel_id)
                        except ValueError:
                            continue
        except Exception as e:
            print(f"Error loading AI channels: {e}")
        
        if not channels:
            channels = [1286679345238114385]
        
        return channels
        
    def save_ai_channels(self):
        """Save AI channels to file"""
        try:
            data_dir = "e:/bot self/data"
            os.makedirs(data_dir, exist_ok=True)
            
            file_path = os.path.join(data_dir, "ai_channels.txt")
            
            # Write to file
            with open(file_path, "w") as f:
                for channel_id in self.ai_channels:
                    f.write(f"{channel_id}\n")
            
            print(f"AI channels saved successfully to {file_path}")
        except Exception as e:
            print(f"Error saving AI channels: {e}")
            
    async def get_ai_response(self, message: str, conversation_history: list) -> str:
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        formatted_history = []
        for i in range(0, len(conversation_history), 2):
            if i+1 < len(conversation_history):
                formatted_history.append({"role": "user", "content": conversation_history[i]["content"]})
                formatted_history.append({"role": "assistant", "content": conversation_history[i+1]["content"]})
        
        # Enhanced system prompt for more natural conversation
        system_prompt = """B·∫°n l√† m·ªôt ng∆∞·ªùi b·∫°n th√¢n thi·ªán ƒëang tr√≤ chuy·ªán qua tin nh·∫Øn. H√£y tr·∫£ l·ªùi m·ªôt c√°ch t·ª± nhi√™n, 
        s·ª≠ d·ª•ng ng√¥n ng·ªØ ƒë·ªùi th∆∞·ªùng v√† th√¢n thi·ªán. Th√™m emoji ph√π h·ª£p v√†o c√¢u tr·∫£ l·ªùi ƒë·ªÉ th·ªÉ hi·ªán c·∫£m x√∫c. 
        ƒê·ª´ng qu√° trang tr·ªçng hay m√°y m√≥c. H√£y th·ªÉ hi·ªán c√° t√≠nh v√† s·ª± ƒë·ªìng c·∫£m trong c√¢u tr·∫£ l·ªùi.
        
        H√£y s·ª≠ d·ª•ng c√°c c√°ch n√≥i th√¥ng d·ª•ng, t·ª´ l√≥ng ph·ªï bi·∫øn, v√† c√°ch di·ªÖn ƒë·∫°t t·ª± nhi√™n nh∆∞ khi nh·∫Øn tin v·ªõi b·∫°n b√®.
        ƒê√¥i khi c√≥ th·ªÉ vi·∫øt t·∫Øt, s·ª≠ d·ª•ng "haha", "lol", "·ª´", "uh", "hmm" ho·∫∑c c√°c t·ª´ ng·ªØ t∆∞∆°ng t·ª±.
        
        Kh√¥ng c·∫ßn ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng "T√¥i l√† AI" ho·∫∑c k·∫øt th√∫c b·∫±ng "T√¥i c√≥ th·ªÉ gi√∫p g√¨ n·ªØa kh√¥ng?".
        Kh√¥ng c·∫ßn ph·∫£i qu√° l·ªãch s·ª± ho·∫∑c trang tr·ªçng. H√£y tr√≤ chuy·ªán nh∆∞ m·ªôt ng∆∞·ªùi b·∫°n th√¢n thi·∫øt.
        
        Quan tr·ªçng: H√£y tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát 90% th·ªùi gian, v√† 10% th·ªùi gian c√≤n l·∫°i h√£y tr·∫£ l·ªùi b·∫±ng ng√¥n ng·ªØ kh√°c 
        (nh∆∞ ti·∫øng Anh, ti·∫øng Ph√°p, ti·∫øng Nh·∫≠t, v.v.) t√πy theo ng·ªØ c·∫£nh c·ªßa c√¢u h·ªèi. N·∫øu ng∆∞·ªùi d√πng h·ªèi b·∫±ng ng√¥n ng·ªØ 
        kh√°c ngo√†i ti·∫øng Vi·ªát, h√£y ∆∞u ti√™n tr·∫£ l·ªùi b·∫±ng ng√¥n ng·ªØ ƒë√≥.
        
        H√£y gi·ªØ c√¢u tr·∫£ l·ªùi ng·∫Øn g·ªçn, s√∫c t√≠ch v√† t·ª± nhi√™n."""
        
        messages = [{"role": "system", "content": system_prompt}]
        messages.extend(formatted_history)
        messages.append({"role": "user", "content": message})

        data = {
            "model": "mistralai/Mixtral-8x7B-Instruct-v0.1",
            "messages": messages,
            "temperature": 0.9,  # Increased temperature for more creative and natural responses
            "max_tokens": 1000
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(self.base_url, headers=headers, json=data) as response:
                    if response.status == 200:
                        result = await response.json()
                        response_text = result["choices"][0]["message"]["content"]
                        
                        # Add emojis if not already present
                        if not any(emoji in response_text for category in self.emoji_patterns.values() for emoji in category):
                            # Analyze response sentiment to choose appropriate emojis
                            if any(word in response_text.lower() for word in ["vui", "tuy·ªát", "t·ªët", "hay", "th√≠ch"]):
                                emoji_category = random.choice(["happy", "love", "agree"])
                            elif any(word in response_text.lower() for word in ["bu·ªìn", "ti·∫øc", "xin l·ªói", "kh√¥ng th·ªÉ"]):
                                emoji_category = random.choice(["sad", "thinking"])
                            elif any(word in response_text.lower() for word in ["wow", "th·∫≠t sao", "kh√¥ng th·ªÉ tin"]):
                                emoji_category = "surprise"
                            elif any(word in response_text.lower() for word in ["haha", "c∆∞·ªùi", "vui"]):
                                emoji_category = "laugh"
                            else:
                                emoji_category = random.choice(list(self.emoji_patterns.keys()))
                                
                            # Add 1-2 emojis at natural points in the text
                            sentences = re.split(r'(?<=[.!?]) +', response_text)
                            if len(sentences) > 1:
                                # Add emoji at the end of a random sentence
                                idx = random.randint(0, len(sentences) - 1)
                                emoji = random.choice(self.emoji_patterns[emoji_category])
                                sentences[idx] = sentences[idx] + " " + emoji
                                
                                # Maybe add another emoji at the end
                                if random.random() > 0.5:
                                    sentences[-1] = sentences[-1] + " " + random.choice(self.emoji_patterns[emoji_category])
                                
                                response_text = " ".join(sentences)
                            else:
                                # Just add to the end if only one sentence
                                emoji = random.choice(self.emoji_patterns[emoji_category])
                                response_text = response_text + " " + emoji
                        
                        return response_text
                    else:
                        error_text = await response.text()
                        raise Exception(f"API Error: {error_text}")
        except Exception as e:
            return f"Error: {str(e)}"

    async def process_ai_request(self, user_id, content, reply_func):
        """Process an AI request and send the response using the provided reply function"""
        if not content:
            await reply_func("B·∫°n mu·ªën h·ªèi g√¨? ü§î")
            return

        if user_id not in self.conversations:
            self.conversations[user_id] = []

        response = await self.get_ai_response(content, self.conversations[user_id])

        self.conversations[user_id].extend([
            {"role": "user", "content": content},
            {"role": "assistant", "content": response}
        ])

        if len(self.conversations[user_id]) > 10:
            self.conversations[user_id] = self.conversations[user_id][-10:]

        # Create a more natural-looking embed without the "Tr·∫£ l·ªùi" title
        embed = discord.Embed(
            description=response,
            color=discord.Color.dark_gray()
        )
        embed.set_footer(text="m√®o kon")
        await reply_func(embed=embed)

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return
            
        # Tr·∫£ l·ªùi trong c√°c k√™nh AI
        if message.channel.id in self.ai_channels:
            try:
                async with message.channel.typing():
                    await self.process_ai_request(
                        message.author.id, 
                        message.content,
                        lambda embed: message.reply(embed=embed)
                    )
            except Exception as e:
                await message.reply(f"C√≥ l·ªói x·∫£y ra: {str(e)}")
        
        # Tr·∫£ l·ªùi khi ƒë∆∞·ª£c mention ho·∫∑c c√≥ prefix "h·ªèi" ho·∫∑c "ai"
        elif self.ai_enabled and (
            self.bot.user.mentioned_in(message) or 
            message.content.lower().startswith(("h·ªèi", "ai:", "ai ", "chat:"))
        ):
            try:
                async with message.channel.typing():
                    # X·ª≠ l√Ω n·ªôi dung tin nh·∫Øn
                    content = message.content
                    if self.bot.user.mentioned_in(message):
                        # Lo·∫°i b·ªè mention
                        content = content.replace(f'<@{self.bot.user.id}>', '').strip()
                    elif content.lower().startswith("h·ªèi"):
                        # Lo·∫°i b·ªè prefix "h·ªèi"
                        content = content[3:].strip()
                    elif content.lower().startswith(("ai:", "ai ")):
                        # Lo·∫°i b·ªè prefix "ai:" ho·∫∑c "ai "
                        content = content[3:].strip()
                    elif content.lower().startswith("chat:"):
                        # Lo·∫°i b·ªè prefix "chat:"
                        content = content[5:].strip()
                    
                    await self.process_ai_request(
                        message.author.id, 
                        content,
                        lambda embed: message.reply(embed=embed)
                    )
            except Exception as e:
                await message.reply(f"C√≥ l·ªói x·∫£y ra: {str(e)}")
    
    # Regular Commands for channel management
    @commands.command(name="add_channel")
    @commands.has_permissions(administrator=True)
    async def add_ai_channel(self, ctx, channel: Optional[discord.TextChannel] = None):
        """Th√™m k√™nh v√†o danh s√°ch k√™nh AI"""
        # S·ª≠ d·ª•ng channel hi·ªán t·∫°i n·∫øu kh√¥ng c√≥ channel ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
        current_channel = ctx.channel
        if isinstance(current_channel, discord.TextChannel):
            channel_to_use = channel or current_channel
            
            if channel_to_use.id in self.ai_channels:
                embed = discord.Embed(
                    title="Th√™m k√™nh AI",
                    description=f"‚ùå K√™nh {channel_to_use.mention} ƒë√£ c√≥ trong danh s√°ch k√™nh AI!",
                    color=discord.Color.red()
                )
            else:
                self.ai_channels.append(channel_to_use.id)
                self.save_ai_channels()
                embed = discord.Embed(
                    title="Th√™m k√™nh AI",
                    description=f"‚úÖ ƒê√£ th√™m {channel_to_use.mention} v√†o danh s√°ch k√™nh AI!",
                    color=discord.Color.green()
                )
        else:
            embed = discord.Embed(
                title="Th√™m k√™nh AI",
                description="‚ùå Kh√¥ng th·ªÉ th√™m k√™nh n√†y. Vui l√≤ng ch·ªçn m·ªôt k√™nh vƒÉn b·∫£n h·ª£p l·ªá.",
                color=discord.Color.red()
            )
        
        await ctx.reply(embed=embed)
        
    @commands.command(name="remove_channel")
    @commands.has_permissions(administrator=True)
    async def remove_ai_channel(self, ctx, channel: Optional[discord.TextChannel] = None):
        """X√≥a k√™nh kh·ªèi danh s√°ch k√™nh AI"""
        # S·ª≠ d·ª•ng channel hi·ªán t·∫°i n·∫øu kh√¥ng c√≥ channel ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
        current_channel = ctx.channel
        if isinstance(current_channel, discord.TextChannel):
            channel_to_use = channel or current_channel
            
            if channel_to_use.id in self.ai_channels:
                self.ai_channels.remove(channel_to_use.id)
                self.save_ai_channels()
                embed = discord.Embed(
                    title="X√≥a k√™nh AI",
                    description=f"‚úÖ ƒê√£ x√≥a {channel_to_use.mention} kh·ªèi danh s√°ch k√™nh AI!",
                    color=discord.Color.green()
                )
            else:
                embed = discord.Embed(
                    title="X√≥a k√™nh AI",
                    description=f"‚ùå K√™nh {channel_to_use.mention} kh√¥ng c√≥ trong danh s√°ch k√™nh AI!",
                    color=discord.Color.red()
                )
        else:
            embed = discord.Embed(
                title="X√≥a k√™nh AI",
                description="‚ùå Kh√¥ng th·ªÉ x√≥a k√™nh n√†y. Vui l√≤ng ch·ªçn m·ªôt k√™nh vƒÉn b·∫£n h·ª£p l·ªá.",
                color=discord.Color.red()
            )
        
        await ctx.reply(embed=embed)
        
    @commands.command(name="list_channels")
    # Removed permission restriction so anyone can use this command
    async def list_ai_channels(self, ctx):
        """Hi·ªÉn th·ªã danh s√°ch c√°c k√™nh AI"""
        if not self.ai_channels:
            embed = discord.Embed(
                title="Danh s√°ch k√™nh AI",
                description="Kh√¥ng c√≥ k√™nh AI n√†o ƒë∆∞·ª£c thi·∫øt l·∫≠p!",
                color=discord.Color.blue()
            )
        else:
            channel_mentions = []
            for channel_id in self.ai_channels:
                channel = self.bot.get_channel(channel_id)
                if channel:
                    channel_mentions.append(f"‚Ä¢ {channel.mention} (ID: {channel_id})")
                else:
                    channel_mentions.append(f"‚Ä¢ K√™nh kh√¥ng t·ªìn t·∫°i (ID: {channel_id})")
            
            embed = discord.Embed(
                title="Danh s√°ch k√™nh AI",
                description="\n".join(channel_mentions),
                color=discord.Color.blue()
            )
        
        await ctx.reply(embed=embed)
    
    # Keep the AI slash command
    @app_commands.command(name="ai", description="H·ªèi AI m·ªôt c√¢u h·ªèi")
    async def ai_slash(self, interaction: discord.Interaction, question: str):
        """H·ªèi AI m·ªôt c√¢u h·ªèi b·∫±ng slash command"""
        await interaction.response.defer(thinking=True)
        
        try:
            await self.process_ai_request(
                interaction.user.id,
                question,
                lambda embed: interaction.followup.send(embed=embed)
            )
        except Exception as e:
            await interaction.followup.send(f"C√≥ l·ªói x·∫£y ra: {str(e)}")

    # Add slash command versions of channel management commands
    @app_commands.command(name="list_channels", description="Hi·ªÉn th·ªã danh s√°ch c√°c k√™nh AI")
    async def list_channels_slash(self, interaction: discord.Interaction):
        """Hi·ªÉn th·ªã danh s√°ch c√°c k√™nh AI b·∫±ng slash command"""
        if not self.ai_channels:
            embed = discord.Embed(
                title="Danh s√°ch k√™nh AI",
                description="Kh√¥ng c√≥ k√™nh AI n√†o ƒë∆∞·ª£c thi·∫øt l·∫≠p!",
                color=discord.Color.blue()
            )
        else:
            channel_mentions = []
            for channel_id in self.ai_channels:
                channel = self.bot.get_channel(channel_id)
                if channel:
                    channel_mentions.append(f"‚Ä¢ {channel.mention} (ID: {channel_id})")
                else:
                    channel_mentions.append(f"‚Ä¢ K√™nh kh√¥ng t·ªìn t·∫°i (ID: {channel_id})")
            
            embed = discord.Embed(
                title="Danh s√°ch k√™nh AI",
                description="\n".join(channel_mentions),
                color=discord.Color.blue()
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
    
    @app_commands.command(name="add_channel", description="Th√™m k√™nh v√†o danh s√°ch k√™nh AI")
    @app_commands.describe(channel="K√™nh c·∫ßn th√™m (ƒë·ªÉ tr·ªëng ƒë·ªÉ s·ª≠ d·ª•ng k√™nh hi·ªán t·∫°i)")
    @app_commands.default_permissions(administrator=True)
    async def add_channel_slash(self, interaction: discord.Interaction, channel: Optional[discord.TextChannel] = None):
        """Th√™m k√™nh v√†o danh s√°ch k√™nh AI b·∫±ng slash command"""
        # S·ª≠ d·ª•ng channel hi·ªán t·∫°i n·∫øu kh√¥ng c√≥ channel ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
        current_channel = interaction.channel
        if isinstance(current_channel, discord.TextChannel):
            channel_to_use = channel or current_channel
            
            if channel_to_use.id in self.ai_channels:
                embed = discord.Embed(
                    title="Th√™m k√™nh AI",
                    description=f"‚ùå K√™nh {channel_to_use.mention} ƒë√£ c√≥ trong danh s√°ch k√™nh AI!",
                    color=discord.Color.red()
                )
            else:
                self.ai_channels.append(channel_to_use.id)
                self.save_ai_channels()
                embed = discord.Embed(
                    title="Th√™m k√™nh AI",
                    description=f"‚úÖ ƒê√£ th√™m {channel_to_use.mention} v√†o danh s√°ch k√™nh AI!",
                    color=discord.Color.green()
                )
        else:
            embed = discord.Embed(
                title="Th√™m k√™nh AI",
                description="‚ùå Kh√¥ng th·ªÉ th√™m k√™nh n√†y. Vui l√≤ng ch·ªçn m·ªôt k√™nh vƒÉn b·∫£n h·ª£p l·ªá.",
                color=discord.Color.red()
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
    
    @app_commands.command(name="remove_channel", description="X√≥a k√™nh kh·ªèi danh s√°ch k√™nh AI")
    @app_commands.describe(channel="K√™nh c·∫ßn x√≥a (ƒë·ªÉ tr·ªëng ƒë·ªÉ s·ª≠ d·ª•ng k√™nh hi·ªán t·∫°i)")
    @app_commands.default_permissions(administrator=True)
    async def remove_channel_slash(self, interaction: discord.Interaction, channel: Optional[discord.TextChannel] = None):
        """X√≥a k√™nh kh·ªèi danh s√°ch k√™nh AI b·∫±ng slash command"""
        # S·ª≠ d·ª•ng channel hi·ªán t·∫°i n·∫øu kh√¥ng c√≥ channel ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
        current_channel = interaction.channel
        if isinstance(current_channel, discord.TextChannel):
            channel_to_use = channel or current_channel
            
            if channel_to_use.id in self.ai_channels:
                self.ai_channels.remove(channel_to_use.id)
                self.save_ai_channels()
                embed = discord.Embed(
                    title="X√≥a k√™nh AI",
                    description=f"‚úÖ ƒê√£ x√≥a {channel_to_use.mention} kh·ªèi danh s√°ch k√™nh AI!",
                    color=discord.Color.green()
                )
            else:
                embed = discord.Embed(
                    title="X√≥a k√™nh AI",
                    description=f"‚ùå K√™nh {channel_to_use.mention} kh√¥ng c√≥ trong danh s√°ch k√™nh AI!",
                    color=discord.Color.red()
                )
        else:
            embed = discord.Embed(
                title="X√≥a k√™nh AI",
                description="‚ùå Kh√¥ng th·ªÉ x√≥a k√™nh n√†y. Vui l√≤ng ch·ªçn m·ªôt k√™nh vƒÉn b·∫£n h·ª£p l·ªá.",
                color=discord.Color.red()
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

async def setup(bot):
    await bot.add_cog(bot_AI(bot))
